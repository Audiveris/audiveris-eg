//-----------------------------------------------------------------------//
//                                                                       //
//                            G l y p h L a g                            //
//                                                                       //
//  Copyright (C) Herve Bitteur 2000-2005. All rights reserved.          //
//  This software is released under the terms of the GNU General Public  //
//  License. Please contact the author at herve.bitteur@laposte.net      //
//  to report bugs & suggestions.                                        //
//-----------------------------------------------------------------------//
//      $Id$
package omr.glyph;

import omr.lag.Lag;
import omr.lag.Oriented;
import omr.util.Logger;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.Collection;

/**
 * Class <code>GlyphLag</code> is a lag of {@link GlyphSection}'s which can
 * be aggregated into {@link Glyph}'s. A GlyphLag keeps an internal
 * collection of all defined glyphs.
 */
public class GlyphLag
    extends Lag<GlyphLag, GlyphSection>
{
    //~ Static variables/initializers -------------------------------------

    private static final Logger logger = Logger.getLogger(GlyphSection.class);

    //~ Instance variables ------------------------------------------------

    /** All glyphs of this GlyphLag, indexed by glyph id */
    protected final SortedMap<Integer, Glyph> glyphs
        = new TreeMap<Integer, Glyph>();

    /** Global id to uniquely identify a glyph */
    protected int globalGlyphId = 0;

    //~ Constructors ------------------------------------------------------

    //----------//
    // GlyphLag //
    //----------//
    /**
     * Create a glyph lag, with a pre-defined orientation
     *
     * @param orientation the desired orientation of the lag
     */
    public GlyphLag (Oriented orientation)
    {
        super(orientation);
    }

    //~ Methods -----------------------------------------------------------

    //----------//
    // addGlyph //
    //----------//
    /**
     * (package access from {@link Glyph}) to add a glyph in the graph
     *
     * @param glyph the newly created glyph
     */
    void addGlyph (Glyph glyph)
    {
        glyphs.put(++globalGlyphId, glyph);
        glyph.setId(globalGlyphId);
        glyph.setLag(this);
    }

    //-------------//
    // removeGlyph //
    //-------------//
    /**
     * (package access from {@link Glyph}) to remove a glyph from the
     * graph
     *
     * @param glyph the glyph to remove
     */
    void removeGlyph (Glyph glyph)
    {
        glyphs.remove(glyph.getId());
    }

    //-------------//
    // createGlyph //
    //-------------//
    /**
     * Create a new glyph instance in the lag
     *
     * @param cl the concrete glyph class to use for instantiation
     * @return the newly created glyph
     */
    public Glyph createGlyph (Class<? extends Glyph> cl)
    {
        try {
            Glyph glyph = cl.newInstance();
            addGlyph(glyph);
            return glyph;
        } catch (InstantiationException ex) {
            ex.printStackTrace();
            return null;
        } catch (IllegalAccessException ex) {
            ex.printStackTrace();
            return null;
        }
    }

    //----------//
    // getGlyph //
    //----------//
    /**
     * Retrieve a glyph via its Id among the lag collection of glyphs
     *
     * @param id the glyph id to search for
     * @return the glyph found, or null otherwise
     */
    public Glyph getGlyph (Integer id)
    {
        return glyphs.get(id);
    }

    //-----------//
    // getGlyphs //
    //-----------//
    /**
     * Export the glyphs of the lag. TBD: should be unmutable ?
     *
     * @return the collection of glyphs
     */
    public Collection<Glyph> getGlyphs ()
    {
        return glyphs.values();
    }

    //----------------//
    // getLastGlyphId //
    //----------------//
    /**
     * Report the latest glyph id so far in this lag
     *
     * @return the latest glyph id generated by the glyph lag
     */
    public int getLastGlyphId()
    {
        return globalGlyphId;
    }

    //------//
    // dump //
    //------//
    /**
     * Prints out major internal info about this glyph lag.
     *
     * @param title a specific title to be used for the dump
     */
    public void dump (String title)
    {
        // Normal dump of sections
        super.dump(title);

        // Dump of glyphs
        for (Glyph glyph : getGlyphs()) {
            System.out.println(glyph.toString());
        }
    }

    //----------//
    // toString //
    //----------//
    /**
     * Return a readable description
     *
     * @return the descriptive string
     */
    @Override
        public String toString ()
    {
        StringBuffer sb = new StringBuffer(256);

        sb.append(super.toString());

        sb.append(" ").append(glyphs.size()).append(" glyphs");

        if (this.getClass().getName() == GlyphLag.class.getName()) {
            sb.append("}");
        }

        return sb.toString();
    }

    //-----------//
    // getPrefix //
    //-----------//
    /**
     * Return a distinctive string, to be used as a prefix in toString()
     * for example.
     *
     * @return the prefix string
     */
    @Override
        protected String getPrefix ()
    {
        return "GlyphLag";
    }
}
